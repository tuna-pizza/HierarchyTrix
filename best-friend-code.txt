// drawer_d3.js: inside HierarchicallyClusteredGraphDrawer class

  drawClusterInclusions(
    svg,
    xCoordMap,
    yCoordMap,
    widthMap,
    xCoordReferenceMap,
    yCoordReferenceMap,
    clusterDistance
  ) {
    // 1. Determine the center of the entire visualization for path adjustments
    const numVertices = this.H.getVertices().length;
    const initialOffsetX = cellSize / 2;
    // Center of the entire drawing space based on the linear layout
    const totalGraphCenterX = initialOffsetX + (numVertices - 1) * vertexDistance / 2;
    
    // Define a large constant for horizontal offset, used only for multi-span edges.
    const xOffsetFactor = (numVertices * vertexDistance) / 10; 
    
    const pathData = [];
    for (const node of this.H.getNodes()) {
      if (node.getParent() !== null) {
        
        // --- 2. Retrieve Coordinates ---
        const referenceX = xCoordReferenceMap.get(node); // Child center X (Top X)
        const referenceY = yCoordReferenceMap.get(node); // Parent's Y level (Top Y)
        const x = xCoordMap.get(node); // Cluster center X (Bottom X)
        const y = yCoordMap.get(node); // Cluster's Y level (Bottom Y)
        const width = widthMap.get(node); // Cluster width (N*cellSize)

        // Check if all coordinates are available
        if (
          [referenceX, referenceY, x, y, width].every((v) => v !== undefined)
        ) {
          // --- 3. Define Anchor Points ---
          const topX1 = referenceX - cellSize / 2;
          const topX2 = referenceX + cellSize / 2;
          const topY = referenceY;

          const bottomX1 = x - width / 2;
          const bottomX2 = x + width / 2;
          const bottomY = y;

          // --- 4. Determine Vertical Span and Path Strategy ---
          const verticalSpan = Math.abs(bottomY - topY);
          let pathString = "";
          let offsetX = 0;
          
          // If the vertical span is significantly greater than one cluster distance, 
          // it spans multiple implied levels.
          if (verticalSpan > clusterDistance * 1.5) {
            
            // --- Multi-Span Path (Wide, Non-Crossing Cubic Bézier) ---
            
            // Calculate Horizontal Offset (Aggressive outward bow)
            if (x < totalGraphCenterX) {
              offsetX = -xOffsetFactor; // Push Left
            } else if (x > totalGraphCenterX) {
              offsetX = xOffsetFactor; // Push Right
            }
            
            // Control Y position is high, close to topY, to force a wide, shallow arc.
            const controlY = topY + clusterDistance * 0.1; 

            // Construct the Wide Cubic Bézier Path:
            pathString = `
              M ${topX1} ${topY}
              C ${topX1 + offsetX} ${controlY}, ${bottomX1 + offsetX} ${controlY}, ${bottomX1} ${bottomY}
              L ${bottomX2} ${bottomY}
              C ${bottomX2 + offsetX} ${controlY}, ${topX2 + offsetX} ${controlY}, ${topX2} ${topY}
              Z
            `;
            
          } else {
            // --- Single-Span Path (Standard Vertical Cubic Bézier) ---
            
            // The middle Y is used for control points, preventing horizontal crossings
            // but keeping the path vertical and neat.
            const middleY = topY + verticalSpan * 0.5; 
            
            // Control points are set vertically halfway down and up, 
            // ensuring the path goes straight down before smoothly curving inward.
            // The X-coordinates are kept near the anchors (topX1, bottomX1)
            pathString = `
              M ${topX1} ${topY}
              C ${topX1} ${middleY}, ${bottomX1} ${middleY}, ${bottomX1} ${bottomY}
              L ${bottomX2} ${bottomY}
              C ${bottomX2} ${middleY}, ${topX2} ${middleY}, ${topX2} ${topY}
              Z
            `;
          }

          // 5. Push data
          pathData.push({
            node: node,
            path: pathString,
          });
        }
      }
    }

    // ... (rest of the method remains the same) ...
  }